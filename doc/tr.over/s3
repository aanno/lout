@Section
   @Title { Objects }
@Begin
@PP
To the expert user, Lout is a high-level functional language with a
relatively small repertoire of primitive features organized around four
key concepts: {@I objects}, {@I definitions}, {@I cross @I references}, 
and {@I galleys}.  An object is a rectangle with at least one horizontal
and one vertical mark protruding from it.  For example,
@ID @Code "Australia"
is an object which is viewed by Lout like this:
@ID @ShowMarks Australia
Horizontal and vertical concatenation operators, denoted by the symbols
@Code "|" and {@Code "/"}, are used to assemble larger objects:
@ID @Code { "USA  |0.2i  Australia" }
is the object
@ID { @ShowMarks USA  |0.2i  @ShowMarks Australia }
The parameters are separated by the length given after the concatenation
symbol (0.2 inches in this example), and their horizontal marks are
aligned.
@PP
Tables are made by combining the two operators, with @Code "|" having
the higher precedence:
@ID  @Code {
             |1m  USA         |1m  "|0.2i" |1m   Australia
/1vx "/0.1i" |    Washington  |    "|"     |     Canberra
}
is the object
@ID {
      @ShowMarks USA &0.4c @Fig { @Line from { 0 0 } to { xsize 0 }
      linestyle { dashed } linewidth { 0.015 cm } 0.8c @Wide {} }
      #{ 0 ymark moveto xsize 10 pt add ymark lineto [ 3 pt ] 0 setdash stroke }
      #@Graphic {1c @Wide }
      |0.2i @ShowMarks Australia
/0.1i @ShowMarks Washington  |     @ShowMarks Canberra
}
The second horizontal concatenation symbol needs no length, since the
first one determines the separation between the two columns created by
the alignment of the vertical marks.  Objects of arbitrary complexity
may be assembled using these and other operators, and braces used for
grouping, in a manner analogous to the assembly of expressions in
programming languages.
@PP
The lengths attached to concatenation symbols have features which permit
objects to be positioned very precisely.  In addition to the usual units
of measurement (inches, centimetres, points, and ems), lengths may be
measured in units of the current font size, space width, inter-line
space, and available width (for centering and right justification).
@PP
There are also six @I gap {@I modes}, which determine where the lengths
are measured from.  Previous examples have used edge-to-edge mode:
@ID @Fig margin { 0c } headstyle { closed } {
@ShowMarks { 0.3c @Wide ^| 0.9c @Wide 0.3c @High ^/ 0.2c @High }
|0.5c
@ShowMarks { 0.3c @Wide ^| 0.9c @Wide 0.3c @High ^/ 0.2c @High }
//0.2c
|1.2c @Arrow arrow { both } { 0.5c @Wide }
}
Lout also provides a mark-to-mark mode, obtained by appending
@Code x to the length:
@ID @Fig margin { 0c } headstyle { closed } {
@ShowMarks { 0.3c @Wide ^| 0.9c @Wide 0.3c @High ^/ 0.2c @High }
|0.5c
@ShowMarks { 0.3c @Wide ^| 0.9c @Wide 0.3c @High ^/ 0.2c @High }
//0.2c
|0.3c @Arrow arrow { both } { 1.7c @Wide }
}
The length will be widened if necessary to prevent the parameters from
overlapping, thus implementing the baseline-to-baseline spacing used
between lines of text.  Other modes provide tabulation from the left
margin, overstriking, and hyphenation.
@PP
The final appearance of an object is affected by a limited amount of
information inherited from the context, principally the font and the
width available for the object to occupy.  There are operators for
setting these attributes:
@ID @Code {
"Slope  @Font  {"
"Hello, world"
"}"
}
produces
@ID {
Slope  @Font  { Hello, world }
}
and in a similar way
@ID @Code {
"1.5i @Wide {"
"(1)  |0.1i  A small"
"indented paragraph"
"of text."
"}"
}
produces
@ID {
1.5i @Wide {
(1)  |0.1i  A small
indented paragraph
of text.
}
}
with the paragraph inheriting and being broken to an available width of
1.4 inches minus the width of (1).  This size inheritance remains secure
through all the complexities of gap modes, mark align&-ment, the @Code
"@Wide" and other operators, and so on, providing a high-level service
comparable in value with strong typing in programming languages.
@End @Section
