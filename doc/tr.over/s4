@Section
   @Title { Definitions }
@Begin
@PP
Lout permits the user to define operators which take objects as
parameters and return objects as results.  This feature, unremarkable
in itself, has some surprising applications, most notably to a problem
which is the litmus test of flexibility in document formatting:  the
specification of page layout.
@PP
The use of operators in document formatting seems to have been pioneered
by the eqn equation formatting language of Kernighan and Cherry
[{@Ref kernighan75}].  In eqn, the mathematical formula
@ID @Eq { { x sup 2 + 1 } over 4 }
for example is expressed as
@ID @Code "{ x sup 2 + 1 } over 4"
This identical expression is also used in Lout, but in Lout the operators
({@Code "sup"}, {@Code over} and so on) have visible definitions which
are easy to modify and extend.
@PP
For example, here is the definition of the @Code over operator as it
appears in the Eq equation formatting package [{@Ref kingston92eq}]:
@ID @Code {
"def over"
"    precedence 54"
"    associativity left"
"    left x"
"    right y"
"{"
"    @OneRow @OneCol"
"    {"
"        |0.5rt  x"
"        ^//0.2f  @HLine"
"        //0.2f  |0.5rt  y"
"    }"
"}"
}
Invokations of @Code over return the object between the braces, with the
formal parameters @Code x and @Code y replaced by actual parameters
which are objects found to the left and right of the @Code over symbol.
@PP
The body of @Code over makes a good demonstration of the way in which
Lout's operators combine together.  All are Lout primitives except
{@Code "@HLine"}, which calls upon Lout's graphics primitives to draw a
horizontal line.  The @Code "//" and @Code "^//" operators are variants
of vertical concatenation which omit mark alignment; the separation
is 0.2 times the current font size.  The two @Code "|0.5rt" operators
center each parameter in the column.  Finally, the @Code "@OneRow" and
@Code "^//" operators work together to ensure that only one horizontal
mark protrudes, rather than three; the result has the structure
@ID @ShowMarks @Eq { { x sup 2 + 1 } over 4 }
and so will be aligned correctly with adjacent parts of the equation.
@PP
As is usual in functional languages, sequences are obtained by recursive
definitions.  For example, the `leaders' often seen in tables of
contents can be generated by the definition
@ID @Code {
"def @Leaders"
"{"
"    ..   @Leaders"
"}"
}
White space after @Code "{" and before @Code "}" is not
significant.  The recursion stops when space runs out, so
@ID @Code {
"1.5i @Wide {"
"Chapter 1  @Leaders  5"
"}"
}
has result
@ID {
1.5i @Wide {
Chapter 1  @Leaders  5
}
}
The final invokation of @Code "@Leaders" is deleted along with any
preceding concatenation operator (or white space in this case).
@PP
The specification of page layout is a major problem for many document
formatters, because the model of a document as a sequence of pages is
built-in, and an armada of tedious commands is required to communicate
with this model:  commands for setting page width and height, margins,
columns, page header and footer lines, and so on.  Even with all these
commands, the formatter will be unable to do such a simple thing as draw
a box around each page, if there is no command for it.
@PP
Lout has no built-in model and no such commands.  Instead, a page is an
object like any other:
@ID @Code {
"def @Page"
"    right x"
"{"
"    8i @Wide 11i @High"
"    {"
"        //1i ||1i x ||1i"
"        //1i"
"    }"
"}"
}
The result of @Code "@Page" is an eight by eleven inch object containing
the right parameter within one inch margins.  A document is a vertical
concatenation of numbered pages:
@ID @Code {
"def @PageList"
"    right @PageNum"
"{"
"    @Page"
"    {"
"        |0.5rt  - @PageNum -"
"        //0.2i  @TextPlace"
"        //1rt   @FootSect"
"    }"
"    //0i"
"    @PageList"
"        @Next @PageNum"
"}"
}
The @Code "@Next" operator is a Lout primitive that returns its right
parameter plus one; all automatic numbering is effected by combining
this operator with recursion.  The result of @Code "@PageList 1" is
the object
@ID {
@LittlePage {
|0.5rt - 1 -
//1.2vx @Code "@TextPlace"
//1rt @Code "@FootSect"
}
//
@LittlePage {
|0.5rt - 2 -
//1.2vx @Code "@TextPlace"
//1rt @Code "@FootSect"
}
//0.2c
8p @Font @Code "@PageList 3"
}
which has the potential to expand to infinitely many pages.
@PP
We conclude this example by defining @Code "@FootSect" to be a small
horiz&-ontal line above a list of @Code "@FootPlace" symbols:
@IL
@LI @Code {
"def @FootList"
"{"
"    @FootPlace"
"    //0.1i @FootList"
"}"
}
@LI @Code {
"def @FootSect"
"{"
"    1i @Wide @HLine"
"    //0.1i @FootList"
"}"
}
@EL
This method of specifying page layout is infinitely more flexible than
the other, since the full resources of the language may be brought to
bear.  Of course, the {@Code "@PageList"}, {@Code "@FootSect"}, and
{@Code "@FootList"} symbols must be expanded only on demand, and we have
yet to see how the {@Code "@TextPlace"} and {@Code "@FootPlace"} symbols
can be replaced by actual text and footnotes.
@End @Section
